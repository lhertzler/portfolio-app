/**
 * Blog Post Data Structure
 * 
 * To add a new blog post:
 * 1. Add a new object to the blogPosts array below
 * 2. Set published: true to make it visible
 * 3. Set featured: true to highlight it on the homepage (optional)
 * 4. Use HTML in the content field for formatting
 * 5. The slug will be used in the URL: /blog/[slug]
 * 
 * Example:
 * {
 *   slug: 'my-new-post',
 *   title: 'My New Post Title',
 *   description: 'A brief description of the post',
 *   date: '2024-01-15',
 *   readTime: '5 min',
 *   category: 'Development',
 *   published: true,
 *   featured: false,
 *   tags: ['nextjs', 'shopify'],
 *   author: 'Luke Hertzler',
 *   content: '<p>Your HTML content here...</p>'
 * }
 */

export type BlogPost = {
  slug: string;
  title: string;
  description: string;
  date: string;
  readTime: string;
  category: string;
  published: boolean;
  content: string; // HTML content - use <p>, <h2>, <h3>, <ul>, <li>, <code>, <pre>, etc.
  tags?: string[];
  author?: string;
  featured?: boolean;
  bannerImage?: string; // Path to banner image (e.g., '/images/blogs/image.png')
};

export const blogPosts: BlogPost[] = [
  {
    slug: 'kavalkades-new-digital-home-how-i-built-modern-music-merch-experience-nextjs',
    title: 'Kavalkade\'s New Digital Home — How I Built a Modern Music & Merch Experience with Next.js',
    description: 'A deep dive into rebuilding Kavalkade\'s band website as a fully integrated music platform, merch store, and fan hub using Next.js, featuring a persistent audio player, media grid, and complete ecommerce system.',
    date: '2025-01-17',
    readTime: '12 min',
    category: 'Development',
    published: true,
    featured: true,
    tags: ['nextjs', 'react', 'ecommerce', 'stripe', 'printful', 'supabase', 'music', 'merch'],
    author: 'Luke Hertzler',
    bannerImage: '/images/portfolios/kavalkade.png',
    content: `<h2>From "Band Website" to a Fully Connected Experience</h2><p>When I rebuilt the site for my band, Kavalkade, I didn't want another cookie-cutter band page with a player slapped on top. I wanted something that actually <strong>felt alive</strong> — a fast, modern, dark, cinematic experience that merges music, media, and merch into one cohesive system instead of scattered features duct-taped together.</p><p>Under the hood it's all powered by <strong>Next.js</strong> and a custom component system I've built up over time. There's a persistent audio player, a video-friendly media grid, and a real ecommerce flow layered together in a way that still feels lightweight and intuitive.</p><p>Think of it like a stripped-down music platform, merch store, and fan hub — all built from scratch, all in one place.</p><h2>Why Next.js Was the Move</h2><p>I'm a big believer that the stack should disappear into the background. Next.js gives me everything I need for that: <strong>speed, clean routing, SEO, and a ridiculous amount of flexibility</strong>.</p><p>I used <strong>Server Components</strong> for performance and data handling, and kept interactive pieces — the music player, media viewers, cart, filters — as client components powered by shared global state. This setup keeps the UI feeling snappy while still letting the dynamic pieces behave like a real application.</p><p>No hacky AJAX, no janky "refresh to reset the audio," none of the old WordPress bullshit I used to fight years ago.</p><h2>Custom Minimal UI, Built for the Band's Aesthetic</h2><p>I wanted the site to feel like Kavalkade — dark, moody, minimal, sharp — not like a template that could belong to literally any band.</p><p>Everything you see is built from a <strong>custom component library</strong>: cards, panels, buttons, overlays, modals, responsive layouts. It keeps the visual language tight across every page while still allowing each section to have its own vibe.</p><p>Just as important: it's highly responsive. Desktop, tablet, mobile — it all adapts cleanly so fans can listen, browse media, or shop without running into friction.</p><h2>The Persistent Music Player</h2><p>My favorite part of the whole build: the <strong>persistent audio player</strong>. When someone hits play, the music keeps going — whether they're scrolling photos, watching videos, or checking out merch.</p><p>The player uses a <strong>singleton global audio engine</strong> that lives outside of the routing layer, so it never unmounts. Pages don't control audio; they talk to the engine. That's how everything stays in sync and feels app-like instead of "just a website with a player."</p><p>I also built a full <strong>player panel</strong> that expands to show artwork, track details, scrubbing, and additional controls. Anything you do there instantly updates the main player, and vice versa.</p><p>Smooth, elegant, and continuous — the way band sites should have worked a decade ago.</p><h2>A Media Grid That Handles Photos &amp; Videos Seamlessly</h2><p>The <strong>Media</strong> page is where Kavalkade's visual identity lives. I built a dynamic media grid that handles both photos and videos with zero awkwardness or layout glitches.</p><p>It supports:</p><ul><li>Images with proper optimization and lazy loading</li><li>Video previews that auto-play when visible</li><li>Filters to switch between photos, videos, or mixed content</li><li>A cinematic modal viewer for full-screen playback</li></ul><p>It's the kind of experience you'd expect from a polished music platform, not a "band website," and that was the goal.</p><h2>Ecommerce, Fulfillment, and Accounts — Fully Integrated</h2><p>Kavalkade's site includes a legit, full-stack merch system — not a Shopify theme, not a redirect, not a cheap embed.</p><p>It supports:</p><ul><li>Product browsing &amp; individual detail pages</li><li>A persistent shopping cart</li><li>Secure checkout via <strong>Stripe</strong></li><li>Automatic order handoff to <strong>Printful</strong> for production &amp; fulfillment</li><li>User accounts powered by <strong>Supabase Auth</strong></li><li>Order history and dashboards inside the app</li></ul><p>When someone buys something, the system handles every step — payment, order creation, fulfillment, and status updates — without any manual work on our end.</p><p>It turns a band website into a fully functioning merch operation tied directly into the fan experience.</p><h2>Account Dashboards &amp; Fan Experience</h2><p>Fans who create an account get a personalized dashboard where they can:</p><ul><li>See past orders</li><li>Check order statuses</li><li>Update their info</li></ul><p>All of this runs on Supabase, which keeps things smooth on the backend while giving users a clean, modern UI.</p><h2>A Build That Matches the Vision</h2><p>Before writing a single line of code I mapped out how all the pieces should connect — music, media, merch, accounts, and the overall vibe. The final product feels exactly like what I imagined: cohesive, fast, modern, and expressive.</p><p>It's everything I love about building with Next.js: a real product, not a patchwork.</p><h2>Want Something Like This Built for You?</h2><p>If you're a musician, brand, startup, or creator and want a <strong>custom-built app or site</strong> with real engineering behind it — not generic templates — I'd love to chat.</p><p>I build <strong>high-performance, modern, minimal</strong> apps that blend design and engineering: persistent experiences, ecommerce systems, media-heavy layouts, and custom dashboards.</p><p>You bring the vision — I'll build the thing. <strong>Reach out anytime.</strong></p>`,
  },
  {
    slug: 'how-i-build-persistent-music-players-in-react-nextjs',
    title: 'How I Build Persistent Music Players in React & Next.js',
    description: 'A technical deep-dive into building persistent music players that keep playing across route changes, using React, Next.js, Zustand, and Web Audio API with canvas visualizations.',
    date: '2025-01-16',
    readTime: '18 min',
    category: 'Development',
    published: true,
    featured: true,
    tags: ['react', 'nextjs', 'zustand', 'web-audio', 'canvas', 'audio-player'],
    author: 'Luke Hertzler',
    bannerImage: '/images/blogs/How I Build Persistent Music Players in React Next.jpg',
    content: `<h2>Introduction</h2><p>For as long as I've been building for the web, I've wanted one specific thing: a music player that keeps playing while you move around the site. No awkward restarts, no janky reloads — just a smooth, app-like audio experience inside a browser. For years that goal fought against the limits of older stacks. Then React and Next.js came along, and suddenly the thing that felt nearly impossible became a clean, reliable pattern.</p><p>In this article, I'll walk you through how I build <strong>persistent music players in React &amp; Next.js</strong>: the architecture, the tradeoffs, and the real-world lessons from pushing this pattern way beyond a simple "play/pause" component. I'll reference the exact approach I used on my own portfolio — a global Zustand store, a shared layout that never unmounts, and a canvas-based waveform visualiser tied to the audio frequencies. If you're an entrepreneur, tech lead, or dev planning a custom app with rich media, this is how I make it feel native, reliable, and fun.</p><hr /><h2>Background: The WordPress &amp; AJAX Era (A.K.A. The Pain)</h2><h3>Trying to Force a Persistent Player into WordPress</h3><p>Long before React took over, I tried to build the first version of SoundVent on WordPress. I wanted exactly what my current portfolio has now: hit play, browse around, keep listening. In that ecosystem, the only mildly feasible approach was to go all-in on <strong>AJAX navigation</strong>. Instead of letting the browser do a full page load, you intercept links, fetch new content over AJAX, and manually swap parts of the DOM while trying to keep the audio element alive.</p><p>On very small sites, it kind of worked. But as soon as I tried to scale it to something more ambitious — a full social network with feeds, profiles, messaging, notifications — the whole thing became fragile. Plugins assumed full reloads. Themes assumed page-level scripts. Caching and SEO collided with AJAX hacks. It was like bolting a spaceship engine onto a family sedan.</p><h3>The Core Problem: Fighting the Platform Instead of Working With It</h3><p>To keep audio persistent in that environment, I had to:</p><ul><li>Intercept every navigation instead of using normal links.</li><li>Issue AJAX requests for every page change.</li><li>Parse the HTML response and surgically replace only specific DOM nodes.</li><li>Re-bind scripts in exactly the right order so plugins wouldn't break.</li><li>Hope updates didn't quietly blow everything up.</li></ul><p>It was brittle by design. WordPress was built around full page loads and PHP templates, not a single long-lived UI tree. I spent more time babysitting the illusion than building the actual product experience.</p><h3>Why Next.js Changed Everything</h3><p>React and Next.js flipped the entire architecture. Instead of hacking around full reloads, I could treat the app as <strong>one persistent React tree</strong> where navigation simply swaps out children. The audio player lives at the layout level — above the individual pages — so it never unmounts when the route changes. No DOM surgery. No plugin roulette. Just a stable parent component and client-side routing optimized for this use case.</p><p>For the first time, a persistent player felt natural, not hacked on. That's the mindset I use now for my portfolio, SoundVent, and any custom app that needs continuous audio.</p><hr /><h2>What a "Persistent Music Player" Really Is</h2><p>When I say "persistent music player," I don't just mean a play/pause button glued to the bottom of the page. In practice, it needs to:</p><ul><li>Keep playing while users navigate between different routes.</li><li>Remember the current track, position, and queue.</li><li>Accept commands from anywhere in the app (play this track, skip, seek, etc.).</li><li>Feel native: no awkward resets or flicker when the route changes.</li><li>Optionally drive visualisations, theming, and UI states across the app.</li></ul><p>In other words, a persistent player is a combination of:</p><ul><li><strong>Global audio state</strong> (stored centrally, not per-page).</li><li><strong>A shared layout</strong> that keeps the player mounted.</li><li><strong>A real audio implementation</strong> (via <code>HTMLAudioElement</code> and/or Web Audio API).</li><li><strong>Integration points</strong> from other components to control it.</li></ul><p>Once you see it as shared state + shared UI + stable layout, the architecture becomes straightforward to design.</p><hr /><h2>The Core Stack: React, Next.js, Zustand &amp; Canvas</h2><h3>React for Components, Next.js for Routing</h3><p>React gives me the component model: small, reusable pieces of UI with props and state. Next.js gives me structure: file-based routing, layouts, server rendering, and app-wide composition. Together, they let me treat the browser like a single application instead of disconnected pages.</p><h3>Zustand for Global Audio State</h3><p>For the player on my portfolio, I use a dedicated Zustand store called <code>usePlayerStore</code>. This store knows:</p><ul><li>The current queue of tracks.</li><li>The currently active track id.</li><li>Whether playback is active or paused.</li><li>The current playback position in seconds.</li><li>Helper actions like <code>playTrack</code>, <code>pause</code>, <code>resume</code>, <code>next</code>, <code>prev</code>, and <code>seek</code>.</li></ul><p>Inside the player component, I destructure exactly what I need:</p><pre><code>const {
  queue,
  currentTrackId,
  isPlaying,
  positionSeconds,
  setQueue,
  playTrack,
  pause,
  resume,
  next,
  prev,
  seek,
} = usePlayerStore();</code></pre><p>This store is the "brain" of the audio system. It doesn't play sound itself — it just describes what should be happening. The player component is responsible for making the browser's audio APIs line up with that state.</p><h3>Canvas for the Waveform Visualiser</h3><p>On top of standard playback, I use a separate component, <code>&lt;WaveformVisualizer /&gt;</code>, that takes the current <code>HTMLAudioElement</code> and an <code>isPlaying</code> flag. Inside, it sets up an <code>AudioContext</code> and <code>AnalyserNode</code>, then draws a bar-style waveform to a canvas on every animation frame. That visual feedback is subtle, but it turns a basic player into something that feels intentionally designed.</p><hr /><h2>Where the Player Lives: Next.js Layouts That Never Unmount</h2><p>The secret to persistence isn't a trick inside the player — it's where the player is mounted in the tree.</p><p>In my portfolio, the <code>&lt;AudioPlayer /&gt;</code> is rendered inside a shared layout under the App Router. That layout wraps all the "app" routes, so when you navigate between pages, the layout (and therefore the player) stays mounted the whole time.</p><p>A simplified version of the structure looks like:</p><pre><code>app/
  layout.tsx          // Global shell (theme, base styles)
  (site)/             // Route group for the main site
    layout.tsx        // Site layout (includes AudioPlayer)
    page.tsx          // Home
    blog/
      page.tsx        // Blog index
    portfolio/
      page.tsx        // Portfolio index
    ...</code></pre><p>And the layout that holds the player might look like this:</p><pre><code>// app/(site)/layout.tsx
import { AudioPlayer } from '@/components/audio-player';

export default function SiteLayout({ children }: { children: React.ReactNode }) {
  return (
    &lt;div className="app-shell"&gt;
      &lt;header&gt;...site header...&lt;/header&gt;
      &lt;main&gt;{children}&lt;/main&gt;
      &lt;AudioPlayer /&gt;
    &lt;/div&gt;
  );
}</code></pre><p>Every page under <code>(site)</code> can interact with the audio store. The player, however, is never torn down when the route changes — which means the music keeps playing.</p><hr /><h2>Inside the Audio Player Component</h2><h3>Ref to the Audio Element</h3><p>In the player component, I create a ref to the underlying <code>&lt;audio&gt;</code> element:</p><pre><code>const audioRef = useRef&lt;HTMLAudioElement | null&gt;(null);</code></pre><p>That ref bridges the React world and the browser audio world. The audio element:</p><ul><li>Receives <code>src</code> updates when the current track changes.</li><li>Listens to events like <code>timeupdate</code>, <code>loadedmetadata</code>, <code>ended</code>.</li><li>Feeds progress and duration back into the Zustand store.</li></ul><h3>Syncing Store State &amp; Audio State</h3><p>There are two main loops:</p><ol><li><strong>Store → Audio</strong>: when <code>isPlaying</code> changes, the effect decides whether to <code>audio.play()</code> or <code>audio.pause()</code>.</li><li><strong>Audio → Store</strong>: as the track plays, a <code>requestAnimationFrame</code> loop reads <code>audio.currentTime</code> and pushes it into <code>positionSeconds</code> in the store.</li></ol><p>That pattern keeps things predictable: the store describes intent, and the player makes sure the audio element matches it.</p><hr /><h2>Letting Any Page Control the Player</h2><p>One of the big wins of the global store approach is that any component can control the player without prop-drilling. For example, a track card in a list can do:</p><pre><code>const { playTrack, setQueue } = usePlayerStore();

const handlePlayClick = () =&gt; {
  setQueue(tracks); // maybe the full playlist
  playTrack(track.id);
};</code></pre><p>That's exactly how my portfolio works: track data lives in a shared <code>tracks</code> module, and UI components simply call the store when they want something to play. The player listens and responds.</p><hr /><h2>Waveform Visualiser: Turning Audio into Motion</h2><p>The waveform visualiser lives in its own component:</p><pre><code>interface WaveformVisualizerProps {
  audioElement: HTMLAudioElement | null;
  isPlaying: boolean;
  className?: string;
}

export function WaveformVisualizer({
  audioElement,
  isPlaying,
  className = '',
}: WaveformVisualizerProps) {
  // ...
}</code></pre><p>Inside, it:</p><ul><li>Creates or reuses an <code>AudioContext</code>.</li><li>Uses <code>createMediaElementSource(audioElement)</code> to connect the audio element.</li><li>Attaches an <code>AnalyserNode</code> to read frequency data.</li><li>Draws a series of bars to a <code>&lt;canvas&gt;</code> on every animation frame while audio is playing.</li></ul><p>It's intentionally defensive: if a source already exists, it reconnects; if something goes wrong, it logs a warning instead of breaking the app. The result is a visual layer that feels smooth and synchronised with the music but doesn't interfere with the core playback logic.</p><hr /><h2>Real UX Touches: Minimised State, Playlist Sheet &amp; Motion</h2><p>On top of the core tech, I layer in UX elements to make the player feel considered:</p><ul><li>A minimised state that tucks the player into a compact bar when you want it out of the way.</li><li>A playlist sheet/modal that shows all available tracks using a <code>&lt;Sheet&gt;</code> component.</li><li>Framer Motion animations for smooth enter/exit/transitions.</li><li>Theme-aware styling so the player feels native to the rest of the site.</li></ul><p>These are built on top of the same foundation: Zustand for state, a persistent layout, and a single <code>&lt;AudioPlayer /&gt;</code> tied to an <code>HTMLAudioElement</code>. The details vary per project, but the underlying pattern is stable.</p><hr /><h2>Common Pitfalls &amp; How I Avoid Them</h2><h3>Strict Mode Double Mounts</h3><p>In development, React Strict Mode can cause effects to run twice, which can lead to duplicate <code>AudioContext</code> instances or repeated setup. I keep audio side effects inside guarded hooks, clean up thoroughly on unmount, and avoid doing heavy setup work directly in render.</p><h3>Hydration &amp; Client-Only APIs</h3><p>Anything that touches <code>window</code>, <code>document</code>, <code>AudioContext</code>, or canvas needs to run on the client. The player and visualiser are declared as <code>'use client'</code> components, and all browser API code lives inside <code>useEffect</code> hooks to avoid hydration mismatches.</p><h3>Overloading the Store</h3><p>It's tempting to dump every bit of UI state into the audio store. I keep it focused on audio (queue, track, position, playback). UI concerns like "is the playlist sheet open?" or "is the player minimised?" live in component-level state or dedicated UI stores. This keeps things easier to reason about.</p><hr /><h2>Quick Takeaways</h2><ul><li>A persistent music player is really about <strong>shared layout + global state</strong>, not DOM tricks.</li><li>Next.js App Router layouts make it natural to keep a player mounted across routes.</li><li>Zustand (or similar) gives you a clean, global audio store that any component can use.</li><li>Web Audio + canvas transforms a plain player into a branded, expressive experience.</li><li>Careful handling of Strict Mode, hydration, and state boundaries keeps the system stable.</li><li>This pattern scales from "simple portfolio flex" to "full media platform" without re-architecture.</li></ul><hr /><h2>Visual &amp; Diagram Ideas</h2><p>Here are a few visuals that would complement this article well:</p><ol><li><strong>Architecture Diagram: "One Tree, One Player"</strong><br />Boxes showing:<ul><li>Top-level <code>SiteLayout</code> with <code>AudioPlayer</code> and <code>AudioProvider</code>/<code>usePlayerStore</code>.</li><li>Nested pages (<code>Home</code>, <code>Blog</code>, <code>Portfolio</code>) swapping under the layout.</li><li>Arrows from pages calling <code>playTrack()</code> into the audio store.</li></ul><em>Alt text:</em> "Diagram of a persistent React and Next.js music player architecture with shared layout and global store."</li><li><strong>State Flow Diagram</strong><br />A simple flow:<ul><li>User clicks a track → component calls <code>playTrack()</code>.</li><li><code>usePlayerStore</code> updates <code>currentTrackId</code> and <code>isPlaying</code>.</li><li><code>AudioPlayer</code> updates the <code>&lt;audio&gt;</code> element and starts playback.</li><li>Audio events update <code>positionSeconds</code> back into the store.</li></ul><em>Alt text:</em> "State flow for a global audio store and player in React and Next.js."</li><li><strong>Layout Structure Visual</strong><br />A diagram of the <code>app/(site)/layout.tsx</code> tree, highlighting the persistent player region and children routes.<em>Alt text:</em> "Next.js App Router layout structure showing a persistent music player component."</li><li><strong>Waveform Visualiser Screenshot</strong><br />A mock or screenshot of the actual player from your portfolio, showing the waveform bars moving as music plays.<em>Alt text:</em> "Custom React and Next.js music player with canvas waveform visualiser."</li><li><strong>Before/After UX Comparison</strong><br />Side-by-side:<ul><li>Left: traditional site where audio restarts on every page load.</li><li>Right: persistent Next.js app where music continues across navigation.</li></ul><em>Alt text:</em> "Comparison between traditional page reload audio and persistent app-wide music player in Next.js."</li></ol><hr /><h2>Conclusion</h2><p>Building a persistent music player used to feel like wrestling the platform. In the WordPress + AJAX era, I spent a lot of time trying to keep one fragile audio element alive while everything else reloaded around it. It was clever in theory, but it never felt stable enough for large, complex systems like a full social network.</p><p>With React and Next.js, especially the App Router and shared layouts, the entire problem looks different. Instead of fighting page reloads, I design a single React tree with a stable layout and a global audio store. The player on my portfolio — with its persistent playback, playlist sheet, waveform visualiser, and smooth navigation — is a direct result of that architecture.</p><p>For entrepreneurs, product teams, and anyone thinking about custom apps, this pattern means you can deliver <strong>app-like audio experiences</strong> in the browser without sacrificing maintainability or performance. And for me as a builder, it's satisfying to know that the player I always wanted years ago is not only possible now — it's something I can design, reason about, and extend with confidence.</p><p>If you're considering a product that needs continuous audio — a music platform, learning environment, content hub, or just a portfolio that quietly flexes your capabilities — React and Next.js give you the right foundation. And if you'd rather not stitch that architecture together alone, I'm always open to talking about what we could build together.</p><hr /><h2>FAQs</h2><h3>Do I need Next.js for a persistent music player, or is React enough?</h3><p>You can technically build a persistent player with plain React and a client-side router, as long as the player lives near the top of your component tree. Next.js just makes the overall app architecture cleaner: file-based routing, shared layouts, server rendering, and a solid pattern for keeping global UI elements (like a player) mounted across navigation.</p><h3>Why did you choose Zustand instead of Redux or Context?</h3><p>For this specific use case, I wanted something lightweight, ergonomic, and easy to scale without a lot of boilerplate. Zustand hits that sweet spot: the API is simple, the store can be colocated with related logic, and components can subscribe to just what they need. React Context can work for smaller setups, but as the audio state grows (queue, progress, controls), Zustand helps keep things maintainable.</p><h3>Can I reuse your pattern without the waveform visualiser?</h3><p>Absolutely. The waveform visualiser is completely optional. The core architecture — a persistent layout, a global player store, and a single audio component wired to that store — works perfectly well on its own. You can always add visualisation later if it fits your brand or product goals.</p><h3>Does this kind of player hurt performance?</h3><p>A well-designed persistent player should have minimal impact on performance. It's just one more component in the tree. The bigger performance wins (or losses) come from how you handle data fetching, rendering strategies, image optimisation, and bundle size. Using Next.js's features and being thoughtful about your architecture will keep your app fast even with continuous audio.</p><h3>What if I want a similar experience in my product?</h3><p>If you're thinking about a music platform, content site, or product that needs continuous audio, the pattern I've described here can be adapted to your requirements — different track sources, custom UI, access control, analytics, and more. The important part is the architecture: keeping the player persistent, the state predictable, and the app structure clean. From there, we can layer on whatever experience your audience needs.</p><hr /><h2>Let's chat!</h2><p>Thanks for diving into this breakdown of how I build persistent music players in React &amp; Next.js. I'd love to hear your thoughts: <strong>if you could add a continuous audio experience to any project you're working on right now, what would it be?</strong> Share your ideas, send this to someone who's dreaming up a custom app, or reach out if you'd like to explore building something like this together.</p>`,
  },
  {
    slug: 'my-react-nextjs-journey-building-modern-web-apps-that-scale',
    title: 'My React & Next.js Journey: Building Modern Web Apps That Scale',
    description: 'A deep dive into my journey from Shopify and WordPress development to building full-scale React and Next.js applications, including the tech decisions, architecture patterns, and lessons learned along the way.',
    date: '2025-01-15',
    readTime: '15 min',
    category: 'Development',
    published: true,
    featured: true,
    tags: ['react', 'nextjs', 'tailwind', 'zustand', 'supabase', 'web-development'],
    author: 'Luke Hertzler',
    bannerImage: '/images/blogs/My React & Nextjs Journey Building Modern Web Apps That Scale.png',
    content: `<h2>Introduction</h2><p>In this post I'll walk you through <strong>my React &amp; Next.js journey</strong> — how I moved from Shopify development and WordPress frustration to architecting full-scale web applications, the tech decisions I made, the systems I built (including SoundVent and my portfolio site), and the lessons I'd share with entrepreneurs, tech nerds, and anyone planning a custom application. If you're curious how modern stacks like React, Next.js, Tailwind, Zustand and Supabase come together — or how to think like someone building at a higher level — you're in the right place.</p><h2>Background: From Shopify + WordPress to Modern Engineering</h2><h3>My Early Years as a Shopify Developer</h3><p>Before React ever entered my radar, I was deep into custom Shopify theme builds and app integrations. I built for real merchants, solved performance issues, tweaked Liquid, created plugins. That experience gave me the fundamentals of commerce logic, UX for shoppers, module-based thinking and real production constraints. However, I was still constrained by what a theme system could deliver. I knew there were limits in flexibility, and every time I tried something outside the norm I hit a roadblock.</p><h3>Trying to Push WordPress Beyond Its Limits</h3><p>Around the same time I also experimented heavily with WordPress. I built membership systems, dashboards, custom plugin stacks, and tried scaling WordPress into something it wasn't built for. Performance floundered, updates broke custom code, plugins conflicted, and I spent more time managing tech debt than building vision. WordPress had served me well for small things — but once I tried to deploy large-scale systems, the ecosystem collapsed under its own weight.</p><h3>The Breaking Point</h3><p>The moment I realized I needed to start over came when I was attempting to build a multi-step internal tool for a merchant: rich UI, complex state, dynamic routing, real-time updates — and WordPress just wasn't built for that. I couldn't build the architecture I imagined. And Shopify theme limitations amplified the frustration. I knew I needed something new.</p><h3>The Decision to Start Over Completely</h3><p>So I tossed aside the comfortable. I chose to rebuild my toolkit. I discovered React, saw component architecture, and felt "this is how my internal thinking works." Then Next.js emerged with routing, SSR/SSG, strong performance, and real-world engineering features. That pivot changed everything: I could build the systems I saw internally instead of battling frameworks that weren't meant for it.</p><h3>How Shopify + WordPress Gave Me the Foundation for React</h3><p>That earlier era mattered. Working Shopify themes taught me commerce logic, performance priority, UI for business. The WordPress experiments taught me architecture fails, plugin brittleness, tech debt pain. When I moved to React/Next.js I didn't come in naive — I came in battle-tested, and ready. This gives me a unique vantage when building web applications now.</p><h2>1. Why I Chose React &amp; Next.js</h2><p>React changed the game because I could break UI into components — small, reusable, predictable. I saw my designs not as pages, but as systems of interacting parts. That mindset matched how I think. Next.js amplified that by adding routing, server-rendering, static generation, and architectural scale. I realized that for custom applications, not just marketing sites, I needed full-stack thinking. React + Next.js gave me that. For entrepreneurs and tech leads looking for app development, this matters: you aren't hiring someone who "knows a theme" — you're hiring someone who thinks in architecture and systems.</p><h2>2. Understanding the Stack: React, Next.js, Tailwind, Zustand</h2><h3>React Component-Based Architecture Explained</h3><p>At its core React is about components: UI units with props, state, lifecycle. For large apps, this means modularity, reuse, predictability. I've leveraged that for features, dashboards, UI systems — everything from small widgets to complex flows.</p><h3>What Next.js Adds on Top of React</h3><p>Next.js gives file-based routing, server rendering (SSR), static generation (SSG), incremental revalidation, and backend API routes. It bridges frontend and backend, letting you serve pages faster, handle data securely, and keep architecture sane at scale.</p><h3>Why Tailwind + Zustand Are Part of My Productivity Build</h3><p>Tailwind accelerated styling: utility classes instead of writing CSS from scratch, all while keeping a consistent design system. Zustand gave me global state without Redux's boilerplate. Combined, they made prototyping fast and architecture disciplined — perfect for React and Next.js web applications that need to move quickly without falling apart later.</p><h2>3. From Idea to Architecture: Mapping Out My First Big App</h2><p>I learned early that writing code without architecture is like painting without a sketch. My process now: visualise the system, draw state flows, plan directories, define component contracts, think about data models. That mental mapping reduced iteration time drastically.</p><p>With SoundVent, for example, I sketched flows for user posts, follow logic, audio pipelines, then mapped them into React and Next.js routes, components, and state stores. The same approach let me complete a full portfolio site — including a custom audio player and component inspector — in about 24 hours. The key wasn't typing speed; it was architectural clarity.</p><h2>4. Real-World Case: SoundVent and the Portfolio Site</h2><p>SoundVent is a full-scale platform built on Next.js and Supabase, with real-time messaging, media uploads, social features, and streaming integrations. My portfolio site became a proof of that capability: it includes a persistent audio player, waveform visualisation, theme switcher, and a dev-inspector overlay that exposes component paths as you hover the UI.</p><p>None of that exists in a typical "portfolio template." It's the result of treating React and Next.js as a canvas, not just a job requirement. For potential clients, it sends a clear signal: this isn't just about shipping pages — it's about building platforms, products, and experiences that go beyond the norm.</p><h2>5. Router Strategy &amp; Layouts in Next.js</h2><p>Next.js supports both the classic Pages Router and the newer App Router. The App Router, with nested layouts and server components, lets you build structures where certain parts of the UI persist while others change — exactly what you need for experiences like continuous music players or global navigation.</p><p>In my portfolio, I use layouts so that the music player and theme controls don't unmount between route changes. That's a small but powerful example: routing decisions define user experience. In custom applications, especially ones with complex flows, this kind of layout thinking is the difference between a smooth app and a frustrating one.</p><h2>6. State Management: Going Beyond React's Built-In State</h2><p>For small apps, React's <code>useState</code> and <code>useReducer</code> are enough. But once you have many screens, shared global state, or features like a persistent player, theme system, notifications, and complex forms, you need something more scalable and predictable.</p><p>I use Zustand for global state management. It strikes a nice balance: simple API, minimal boilerplate, solid performance. I keep stores domain-based — for example, one for audio, one for UI/theme, one for auth, one for data. That structure keeps things maintainable, and makes it easy to understand the flow of data in the app. For clients, this means the app is more reliable, easier to extend, and less likely to devolve into "spaghetti state".</p><h2>7. Performance &amp; SEO: Why Next.js Matters for Apps</h2><p>One of the most powerful parts of Next.js is its rendering flexibility. You can choose between server-side rendering (SSR), static site generation (SSG), incremental static regeneration (ISR), or client-side rendering (CSR), depending on the needs of each page or route.</p><p>For marketing and landing pages, I lean on SSG or ISR for speed and reliability. For dashboards and authenticated experiences, SSR or a hybrid approach often makes more sense. The result is a React and Next.js application that loads quickly, ranks better in search, and feels snappier. For entrepreneurs and product teams, this directly affects engagement, conversions, and perceived product quality.</p><h2>8. Database Architecture &amp; Backend Integration</h2><p>On the backend side, I use Supabase — essentially a managed Postgres with auth, storage, and real-time capabilities baked in. Designing SoundVent's schema forced me to think deeply about database architecture: many-to-many relationships, row-level security, indexing, naming conventions, and data access patterns.</p><p>For example, mapping things like users to posts, media to posts, likes, comments, and follows required consistent, scalable relational design. I had to consider questions like "How will this be queried?" and "What happens when we have millions of records?" That discipline carries over to client projects: instead of just "getting it working," I design systems that can grow.</p><h2>9. Custom UI Systems &amp; Design Systems</h2><p>I don't treat UI as a one-off theme; I treat it as a system. Components are built as primitives and patterns that can be reused across the app. Tailwind helps here by making it easy to keep spacing, colors, typography, and states consistent.</p><p>In my portfolio and in SoundVent, the same underlying patterns power modals, cards, panels, and layouts. A single design system powers both the "marketing" surfaces and the "application" surfaces. That kind of consistency is what makes apps feel cohesive and intentional, and it also speeds up development when new features are needed.</p><h2>10. The Role of AI in My Workflow</h2><p>AI coding assistants play a big role in how I work now, but not as a substitute for understanding. They're accelerators. Instead of manually typing boilerplate or repetitive patterns, I describe what I need: components, state shapes, APIs, layouts. The AI generates a first pass; I refine, correct, and evolve it.</p><p>The result is a shift from "coder" to "architect." I spend more time thinking about system design, user experience, and correctness, and less time fighting syntax. For clients, that means I can ship complex applications faster — but with the same level of care and structural integrity.</p><h2>11. Lessons Learned &amp; Mistakes Made</h2><p>I've learned not to chase features for their own sake. Feature bloat can make an app confusing and hard to maintain. The key is to focus on features that move the needle: better UX, clearer workflows, deeper insight, smoother performance.</p><p>I've also learned that speed doesn't have to mean chaos. With a solid architecture and good patterns, you can move quickly without destroying the codebase. The painful missteps from my WordPress days taught me what tech debt looks like and how hard it is to undo. React and Next.js have given me a second chance to build with more discipline and intention.</p><h2>12. For Entrepreneurs &amp; Agencies: What This Means for You</h2><p>If you're planning a custom application or platform, the tech stack and who implements it matters a lot. You want someone who understands React and Next.js, but also state management, database design, routing strategies, and performance. You also want someone who has lived through real constraints — not just someone who can stitch together tutorials.</p><p>My journey from Shopify and WordPress into React, Next.js, Supabase, Tailwind, and Zustand isn't just a tech story. It's a story of learning what doesn't work long-term, and choosing tools that can keep up with serious ideas. If you're an entrepreneur, founder, or agency looking for a partner to build custom systems, this is the mindset I bring to the table.</p><h2>13. Looking Ahead: What's Next for My Stack</h2><p>The React and Next.js ecosystem is still evolving. Next.js continues to push forward with new routing patterns, React Server Components, performance improvements, and better DX. On my side, I'm interested in deeper integrations between audio, data, and UI — expanding SoundVent, refining my design systems, and continuing to experiment with AI-assisted development.</p><p>The core principle, though, stays the same: build systems that are fast, clear, intentional, and a joy to use. Everything else is just an evolving toolset in service of that goal.</p><h2>14. Quick Takeaways</h2><ul><li>Choose a stack that supports architecture: React + Next.js excel at this.</li><li>Map systems before coding: flows, state, and data should be intentional.</li><li>Use UI systems, not ad-hoc components, for consistency and speed.</li><li>Performance and SEO matter even for "apps," not just marketing sites.</li><li>Database design (many-to-many, RLS, indexing) is not optional at scale.</li><li>Unique features like audio players or inspectors are powerful capability signals.</li><li>AI is a multiplier when guided by clear thinking — not a replacement for it.</li></ul><h2>FAQs</h2><h3>What is the difference between React and Next.js?</h3><p>React is a JavaScript library for building user interfaces with components. Next.js is a framework built on top of React that adds routing, server-side rendering, static generation, and backend capabilities. Together they let you build scalable, high-performance web applications.</p><h3>Why use Tailwind and Zustand together with React/Next.js?</h3><p>Tailwind CSS speeds up styling and keeps your UI consistent using utility classes. Zustand provides a simple, efficient way to handle global state without the complexity of larger libraries. Using them together with React and Next.js helps you build custom apps and dashboards quickly while keeping the code maintainable.</p><h3>How important is database architecture in web app development?</h3><p>Database architecture is crucial. Poor design leads to slow queries, bugs, and painful refactors. When building with Next.js and Supabase, modelling relationships (including many-to-many), using proper indexing, and applying row-level security where needed ensures your app can scale securely and efficiently.</p><h3>Can AI genuinely help my React/Next.js development workflow?</h3><p>Yes — as long as you know what you're doing. AI can generate components, suggest patterns, and handle repetitive work, but it can't replace architectural thinking. The best results come when you use AI as an assistant: you define the vision, it handles some of the grunt work, and you maintain quality control.</p><h3>What should I consider when hiring a developer for custom React/Next.js applications?</h3><p>Look for someone who understands React, Next.js, state management, UI systems, database design, and performance. Ask about past platforms they've built, not just landing pages. Make sure they can talk about architecture, not just code snippets — especially if you're planning a serious product or internal tool.</p><h2>Let's chat!</h2><p>Thanks for reading my journey. I'd love to hear from you: <strong>what's your biggest challenge when planning or building a custom web app?</strong> Drop a comment, share this article with someone who's exploring React and Next.js, or reach out if you're thinking about building something ambitious. I'm always interested in talking with entrepreneurs, tech leads, and curious builders about what's possible.</p><h2>References</h2><ul><li>Tanga, M. "SSR vs. SSG in Next.js: Differences, Advantages, and Use Cases." Strapi Blog, 2024.</li><li>Sundaram, N. "Understanding Next.js Rendering Methods: SSR, CSR, SSG, and ISR." Medium, 2024.</li><li>"Next.js." Wikipedia, 2025.</li><li>"Comparing SSR and SSG in Next.js: When to Use Each." dev.to, 2024.</li><li>Leitner, M. "Building a Blog with Next.js 13 and React Server Components." MaxLeiter Blog, 2023.</li></ul>`,
  },
  {
    slug: 'how-i-built-10-apps-in-5-months-and-launched-soundvent',
    title: 'How I Built 10 Apps in 5 Months — And Launched SoundVent',
    description: 'The technical journey behind building SoundVent — a unified music platform that pushed me harder than anything I\'ve done in my career.',
    date: '2024-12-20',
    readTime: '12 min',
    category: 'Development',
    published: true,
    featured: true,
    tags: ['nextjs', 'supabase', 'react', 'soundvent', 'full-stack'],
    author: 'Luke Hertzler',
    bannerImage: '/images/blogs/SV-Laptop-Front.png',
    content: `<p>Today is a milestone I'll never forget:</p><p><strong>SoundVent Beta is officially LIVE.</strong></p><p>It's the most ambitious software project I've ever built — and the most meaningful.</p><p>A music platform built <em>by artists, for artists</em>, where music, video, social networking, messaging, merch, events, and community finally live together in one place.</p><p>But behind the polished UI and clean interface is a technical journey that pushed me harder than anything I've done in my career.</p><p>This is that story.</p><hr><h2><strong>A Vision 10 Years in the Making</strong></h2><p>Ten years ago, SoundVent started as an idea Anthony Garay brought to me — a vision for a unified music platform that didn't exist yet. I believed in the idea instantly, but the tools just weren't there.</p><p>Fast-forward a decade.</p><p>The tech had evolved.</p><p>And so had I.</p><p>I had spent years building large-scale Shopify ecosystems, solving performance problems, architecting backend systems, and designing UX for high-volume stores. But ironically, when it came time to build SoundVent again, I realized the stack I knew best — Shopify + apps + theme development — <strong>couldn't come close</strong> to supporting the scope of what we wanted.</p><p>SoundVent wasn't a store — It wasn't a blog — It wasn't a media player — It wasn't a social feed.</p><p>It was <strong>all of those things at once.</strong></p><p>So the only way forward… was starting over.</p><hr><h2><strong>The Honest Truth: When I Started, I Barely Knew React</strong></h2><p>This might surprise people.</p><p>Five months ago, I knew <strong>just enough React to get by</strong>.</p><p>Component basics. State. Props. Some hooks. Nothing too complex.</p><p>But I didn't know:</p><p></p><ul><li><p>Next.js deeply</p></li><li><p>Server components</p></li><li><p>Suspense</p></li><li><p>Complex client-side state patterns</p></li><li><p>Auth hydration</p></li><li><p>Supabase RLS</p></li><li><p>Media pipelines</p></li><li><p>Streaming</p></li><li><p>Real-time messaging</p></li><li><p>Advanced routing</p></li><li><p>Stripe Connect multi-vendor payouts</p></li><li><p>Large-scale database design</p></li><li><p>Product schema architecture</p></li><li><p>Messaging systems</p></li><li><p>Publishing workflows</p></li><li><p>Realtime feeds</p></li><li><p>File storage performance tuning</p></li></ul><p></p><p>SoundVent was going to require… all of that.</p><p>And so began the grind.</p><hr><h2><strong>5 Months. Thousands of Hours. Countless All-Nighters.</strong></h2><p>Every day was a marathon.</p><p>Most nights didn't end until 3am.</p><p>Console logs became my second monitor.</p><p>Supabase Studio basically lived in my bloodstream.</p><p>Next.js documentation became bedtime reading.</p><p></p><p>I wasn't just learning a framework.</p><p>I was building a full ecosystem.</p><p>Not one app — <strong>ten apps in one:</strong></p><p></p><ul><li><p>A music player</p></li><li><p>A video streaming platform</p></li><li><p>A social network</p></li><li><p>A real-time messaging system</p></li><li><p>A product creator (rivaling Shopify's)</p></li><li><p>A blog platform</p></li><li><p>A discovery engine</p></li><li><p>A profile system</p></li><li><p>An events/ticketing foundation</p></li><li><p>A commerce engine</p></li></ul><p></p><p>Each one is normally its own startup.</p><p>I had to build all of them — alone — in five months.</p><hr><h2><strong>The Tech Stack That Made It Possible</strong></h2><p>In the end, the modern web carried me:</p><h3><strong>React + Next.js (14)</strong></h3><p>This framework changed everything for me.</p><p>I went from "What even is a server component?" to "I never want to build without this again."</p><p>I genuinely fell in love with Next.js.</p><p>It feels like the framework I was always waiting for.</p><h3><strong>Supabase</strong></h3><p>Auth, Postgres, file storage, real-time, and RLS security — all in one place.</p><p>I pushed Supabase hard:</p><p></p><ul><li><p>multi-tenant profiles</p></li><li><p>secure media uploads</p></li><li><p>real-time feeds</p></li><li><p>messaging</p></li><li><p>notifications</p></li><li><p>relational tagging</p></li><li><p>product variants</p></li><li><p>categories</p></li><li><p>subgenres</p></li><li><p>analytics</p></li><li><p>ticketing groundwork</p></li></ul><p></p><p>Supabase handled it like a champ.</p><h3><strong>Mux</strong></h3><p>Video and audio streaming done right.</p><p>Reliable. Fast. Clean.</p><p>Exactly what SoundVent needed.</p><h3><strong>Stripe Connect</strong></h3><p>For multi-vendor commerce — the correct way to do payouts.</p><h3><strong>Tailwind + shadcn/ui</strong></h3><p>Designing an entire platform solo requires incredible efficiency.</p><p>Tailwind + shadcn let me move at lightning speed.</p><hr><h2><strong>There Were Walls. Lots of Walls.</strong></h2><p>I hit:</p><p></p><ul><li><p>SSR hydration issues</p></li><li><p>Auth race conditions</p></li><li><p>Middleware breaking at 2am</p></li><li><p>RLS policies that locked me out of my own tables</p></li><li><p>State management loops</p></li><li><p>Real-time listeners multiplying</p></li><li><p>Storage URLs breaking</p></li><li><p>"Why is this 500ing only in production?" moments</p></li><li><p>Stripe onboarding logic nightmares</p></li><li><p>React component hell</p></li><li><p>Media gallery staleness</p></li><li><p>Phantom re-renders</p></li><li><p>TypeScript gaslighting</p></li><li><p>Edge-case errors from libraries that never documented them</p></li></ul><p></p><p>But every wall came with a breakthrough.</p><p>Every bug made the architecture clearer.</p><p>Every failure made the product stronger.</p><p></p><p>I didn't want to just build SoundVent.</p><p>I wanted to build it <em>right.</em></p><hr><h2><strong>Built By Artists, For Artists</strong></h2><p>What made this grind worth it is simple:</p><p>We're <strong>musicians first.</strong></p><p>Anthony — an incredible drummer with visionary ideas.</p><p>Me — lead guitarist &amp; songwriter for Kavalkade.</p><p>Danny — a bassist with extensive touring experience.</p><p></p><p>We built SoundVent because we lived the problem.</p><p>Because we wanted a platform that respected the craft.</p><p>Because we wanted something better, more integrated, and more fair.</p><p>Music is at our core — and SoundVent reflects that.</p><hr><h2><strong>What SoundVent Is Today</strong></h2><p>SoundVent Beta includes:</p><p>🎵 <strong>Music &amp; Video Uploads</strong></p><p>🔥 <strong>Real-time social feed</strong></p><p>💬 <strong>Messaging &amp; notifications</strong></p><p>👥 <strong>Follow system</strong></p><p>🎸 <strong>Artist Profiles</strong></p><p>🛒 <strong>A full product creator (variants, digital, subscriptions, shipping, SEO, etc.)</strong></p><p>🎫 <strong>Events system foundation</strong></p><p>🌐 <strong>Discover page</strong></p><p>📱 <strong>Mobile-first UI</strong></p><p>⚡ <strong>Supabase real-time backend</strong></p><p>It's Instagram, Spotify, YouTube, Shopify, TikTok, and Ticketmaster — <strong>integrated thoughtfully into one coherent experience.</strong></p><p>This isn't a tool.</p><p>It's an ecosystem.</p><hr><h2><strong>The Roadmap</strong></h2><p>Coming next:</p><p></p><ul><li><p>Live streaming</p></li><li><p>Print-on-demand integration</p></li><li><p>Groups &amp; communities</p></li><li><p>Ticketing</p></li><li><p>Native mobile app</p></li><li><p>Advanced analytics</p></li><li><p>AI-assisted tools for artists</p></li><li><p>DSP ingestion pipeline (later phase)</p></li></ul><p></p><p>And much more.</p><hr><h2><strong>SoundVent is live.</strong></h2><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.soundvent.com"><strong>https://www.soundvent.com</strong></a></p><p>If you're an engineer, musician, or someone passionate about creator platforms, I'd love for you to check it out.</p><p>This project pushed me harder than anything I've ever built — and I couldn't be more proud of where it's going.</p><p>Thanks to everyone who supported this journey.</p><p>The next chapter of music starts now.</p>`,
  },
];

// Helper function to get a post by slug
export function getPostBySlug(slug: string): BlogPost | undefined {
  return blogPosts.find((post) => post.slug === slug && post.published);
}

// Helper function to get all published posts
export function getAllPosts(): BlogPost[] {
  return blogPosts.filter((post) => post.published);
}

// Helper function to get featured posts
export function getFeaturedPosts(): BlogPost[] {
  return blogPosts.filter((post) => post.published && post.featured);
}

// Helper function to get posts by category
export function getPostsByCategory(category: string): BlogPost[] {
  return blogPosts.filter((post) => post.published && post.category === category);
}

